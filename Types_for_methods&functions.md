# [Типи для методів та функцій](Types_for_methods&functions.md)

## Return Type

це тип даних, який функція повертає під час її виклику. **TypeScript** дозволяє вказувати тип значення, що повертається для функцій, що допомагає зробити ваш код більш зрозумілим і безпечним.

```ts
function greet(): string {
  return "Hello, world!";
}

let result = greet();
```

Розглянемо цей приклад. Тут функція greet має тип значення, що повертається string. Це означає, що ми гарантуємо, що ця функція завжди буде повертати рядок, але так само ми і контролюємо себе, якщо ми спробуємо змінити цю функцію так, щоб вона повертала число, TypeScript видасть помилку, контролюючи тим самим нас від ненавмисних змін типу.



Ми отримали помилку, оскільки реальний тип значення, що повертається, не збігається з тим, який був оголошений у функції.


Для стрілочних функцій схожий синтаксис.

```ts
const greet = (): string => {
  return "Hello, world!";
}

let result = greet();
```

Тут **greet** — це стрілочна функція, яка повертає рядок. Ми визначаємо тип значення, що повертається (**`string`**) після списку аргументів і перед стрілкою **(=>)**.



Давайте розглянемо ситуацію, де ми хочемо написати функцію, що отримує список користувачів та повертає імена цих користувачів у вигляді рядка. Ось як ми можемо типізувати таку функцію:






У цьому прикладі функція getUserNames приймає масив об'єктів типу User та повертає масив рядків.



Вказування типу значення, що повертається — це не тільки зручний спосіб документування функцій, але й важливий інструмент контролю коректності вашого коду. Він дозволяє компілятору TypeScript перевірити, чи функція дійсно повертає те, що ви припускали, і видати помилку, якщо це не так.



Важливо також зазначити, що TypeScript здатний автоматично визначати типи значень функцій, що повертаються, на основі їх реалізації. Так, якщо ви не вказали тип значення, що повертається явно, але ваша функція повертає, наприклад, рядок, TypeScript автоматично присвоїть цій функції тип значення, що повертається string.




## Void



Тип void у TypeScript використовується для позначення відсутності будь-якого типу взагалі, і зазвичай використовується як тип функцій, що повертається, в якому функції не повертають значення.



Таких функцій у коді багато, давайте розглянемо на прикладі:






У цьому прикладі функція logMessage приймає один параметр — message типу string і нічого не повертає, тому тип, що повертається — void.



Тип void часто використовується в callback-функціях або функціях зворотного виклику, де ви хочете бути впевнені, що функція не повертає значення, і тому не важливо, що повертає функція зворотного виклику.






У цьому прикладі функція doSomething приймає функцію зворотного виклику callback, що не повертає жодного значення.

## Never



Це коли функція ніколи не закінчується та нічого не повертає. Часто тип never використовується для функцій, які завжди викидають вийняток або у нескінченних циклах. 



Ось деякі приклади його використання:






У першому прикладі функція throwError викидає помилку і ніколи не повертає значення, тому тип, що повертається — never.



У другому прикладі функція infiniteLoop входить у нескінченний цикл і ніколи не завершується, тому її тип, що повертається, теж never.



Наприклад, listen в express, оскільки підключення до сервера є постійне і теж має тип never.



Будь-які спроби присвоїти значення змінної value, яка має тип never, призводять до помилки компіляції.




## Function Type



Ми можемо описати функцію як тип. TypeScript дозволяє визначити типи параметрів, які функція набуває, і тип значення, що повертається. Це робить код більш надійним та зручним для читання та розуміння.



Ось приклад типу функції у TypeScript:






У цьому прикладі myFunc визначено як функцію, яка приймає два аргументи: рядок і число, і нічого не повертає (void). Потім ми присвоюємо функцію, що відповідає цьому типу функції, змінній myFunc.



Це дуже зручно для callback, давайте винесемо опис в окремий тип.






Ми можемо підвищити гнучкість. Замість того, щоб обмежувати тип CallbackType, який приймає рівно два числові аргументи, можна допустити функції, які можуть приймати будь-яку кількість аргументів.



type CallbackType = (...nums: number[]) => number;

function calc(param1: number, param2: number, callback: CallbackType): void {
  console.log('Result:', callback(param1, param2));
}

calc(1, 1, (num1, num2) => num1 + num2);
calc(10, 5, (num1, num2) => num1 - num2);


Але не завжди буде розумно так робити. Іноді строгість — запорука порядку.